from typing import Any, Callable, TypeVar, Dict, Optional, overload

T = TypeVar("T")

# Types
UUID4 = Any
NonNegativeInt = int
PositiveInt = int
NonNegativeFloat = float

# Classes
class BaseModel:
    def __init__(self, **kwargs: Any) -> None: ...
    def model_dump(self, *, mode: str = ..., exclude: Any = ..., **kwargs: Any) -> Dict[str, Any]: ...
    @classmethod
    def model_validate(cls, obj: Any, *, strict: bool | None = ..., from_attributes: bool | None = ..., context: dict[str, Any] | None = ...) -> Any: ...
    model_config: Any

class TypeAdapter:
    def __init__(self, type_: Any) -> None: ...
    def dump_python(self, obj: Any, *, mode: str = ...) -> Any: ...

# Functions
def Field(default: Any = ..., **kwargs: Any) -> Any: ...
def PrivateAttr(default: Any = ...) -> Any: ...
def ConfigDict(**kwargs: Any) -> Any: ...
def field_serializer(field: str, **kwargs: Any) -> Callable[[Any], Any]: ...

# The fix: defined as property to satisfy type checkers treating accessing the field as property access
def computed_field(func: Callable[..., T]) -> property: ...

# Validators
class AfterValidator:
    def __init__(self, func: Callable[[Any], Any]) -> None: ...
